## ΣΥΣΤΗΜΑΤΑ ΔΙΑΧΕΙΡΙΣΗΣ ΒΑΣΕΩΝ ΔΕΔΟΜΕΝΩΝ 2021-2022

### Ομάδα:
Αγγελική Αποστόλου, ΑΜ Π19015
Αντωνία Γιαννουλάκη, ΑΜ Π19251

### Άσκηση ACID
Για την άσκηση ACID δημιουργήσαμε 3 συναρτήσεις στο αρχείο database.py:
• begin_transaction (εκκίνηση διαδικασίας – προσθήκη checkpoint)
• rollback (αναίρεση αλλαγών)
• commit (σώσιμο αλλαγών)
Αρχικά μέσα στη συνάρτηση __init__ δηλώνουμε ένα flag checkpoint το οποίο θα μας χρησιμεύσει στο να ξέρουμε αν υπάρχει κάποιο checkpoint ή όχι. Ύστερα στο αρχείο mdb.py, προσθέσαμε στα keywords (στη συνάρτηση interpret) 3 καινούργια keywords. Το begin transaction, το rollback και το commit. Αυτό για να μπορούμε να τα χρησιμοποιήσουμε.
Στην begin_transaction πρώτα ελέγχουμε αν το checkpoint είναι true. Αν είναι τότε, σημαίνει ότι υπάρχει ήδη ένα checkpoint και το transaction έχει ξεκινήσει επομένως, εμφανίζεται error. Αν όχι τότε δημιουργούμε ένα κάνοντας το checkpoint = True.
Στην rollback πρώτα ελέγχουμε αν το checkpoint είναι true. Αν είναι τότε, κάνουμε το checkpoint = False, δηλαδή αφαιρούμε το checkpoint, και φορτώνουμε την ήδη υπάρχουσα βάση που δεν έχει, προφανώς, καμία αλλαγή καλώντας την self.load_database(). Αν δεν είναι τότε, εμφανίζεται error αφού δεν υπάρχει κάποιο checkpoint για να κάνουμε rollback και να επιστρέψουμε.
Στην commit πάλι ελέγχουμε πρώτα τι είναι το checkpoint. Αν είναι true τότε, αφαιρούμε το checkpoint κάνοντάς το false και στη συνέχεια κάνουμε save την όποια αλλαγή υπάρχει καλώντας την self.save_database(). Αν είναι false τότε, εμφανίζεται error καθώς δεν υπάρχει κάτι για να κάνουμε commit.

-- Παράδειγμα εκτέλεσης

![image](https://github.com/apostolouagg/miniDB/assets/61296853/720ee72c-5e23-4a30-9e1a-7fedaffc618e)

### Άσκηση Distinct
Αρχικά βάζουμε μια μεταβλητή distinct = False. Έπειτα ελέγχουμε αν ο χρήστης έγραψε τη λέξη distinct ως εντολή. Αν ναι τότε την αφαιρούμε από τις εντολές (έτσι ώστε να λειτουργήσει ομαλά ο υπόλοιπος κώδικας), όμως κάνουμε το distinct = True.
Λίγο παρακάτω δημιουργούμε μια if όπου τσεκάρουμε αν έχει γράψει τη λέξη distinct ο χρήστης και μέσα της γράψαμε όλο τον κώδικα που χρειάζεται.
Αρχικά, δημιουργούμε μια λίστα η οποία θα πάρει μέσα της τα δεδομένα της κάθε γραμμής και τα index τους. Τρέχουμε μια for μέσα στη rows, η οποία περιέχει το index των εγγραφών που θα εμφανιστούν. Σε κάθε επανάληψη γίνεται το εξής:
Προσθέτουμε στη λίστα rowsData 2 στοιχεία. Το row που είναι το id της γραμμής του table και μια κενή λίστα η οποία θα δεχτεί τα στοιχεία μιας γραμμής.
Μετά με άλλη μια for που περνάει από κάθε στήλη του table και μέσα της εκτελούμε το rowsData[-1][1].append(self.data[row][colID]).
Αυτό σημαίνει ότι στο πιο πρόσφατο στοιχείο της λίστας rowsData ([rows,[]]) κάνουμε target την κενή λίστα και της προσθέτουμε τα στοιχεία της συγκεκριμένης γραμμής.
Οπότε τώρα έχουμε μια λίστα με τα στοιχεία του table και ακολουθεί το φιλτράρισμα.
Δημιουργούμε 2 λίστες, την newRowsID που θα δεχτεί το index των γραμμών που θα εμφανίσουμε στο τέλος, και την newRows που θα δεχτεί τα στοιχεία (values) που θα εμφανίσουμε στο τέλος.
Τρέχουμε μια for στη rowsData και παίρνουμε το idx (index) και το row (τα στοιχεία). Αν τα στοιχεία ΔΕΝ υπάρχουν μέσα στη newRows τότε βάζουμε τα στοιχεία στη newRows και το index τους στη newRowsID. Με αυτή την εντολή εξετάζουμε αν υπάρχει κάτι 2 φορές μέσα στις τελικές λίστες, επομένως πραγματοποιείται επιτυχώς το φιλτράρισμα.

-- Παράδειγμα εκτέλεσης

![image](https://github.com/apostolouagg/miniDB/assets/61296853/5b3cd087-4c3e-4803-8d96-a787ac7c77c0)

![image](https://github.com/apostolouagg/miniDB/assets/61296853/19746fb9-a92c-4ce3-b25a-f7ea61ece1e4)

![image](https://github.com/apostolouagg/miniDB/assets/61296853/d541986e-456c-41c4-a715-773b5e8bc997)

![image](https://github.com/apostolouagg/miniDB/assets/61296853/fb86cbcf-509c-4304-a949-62721f053b39)

![image](https://github.com/apostolouagg/miniDB/assets/61296853/337f03a6-8e1f-4f52-a8a7-abbc031c3e9b)

![image](https://github.com/apostolouagg/miniDB/assets/61296853/0805c057-1404-4e64-a035-0878672e0332)
